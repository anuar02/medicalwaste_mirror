stages:
  - build
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""

# Build images separately to avoid context issues
build-frontend:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker build -t $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA ./frontend
    - docker push $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/frontend:latest
    - docker push $CI_REGISTRY_IMAGE/frontend:latest

build-backend:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker build -t $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA ./backend
    - docker push $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/backend:latest
    - docker push $CI_REGISTRY_IMAGE/backend:latest

build-nginx:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - |
      cat > Dockerfile.nginx << 'EOF'
      FROM nginx:1.25
      
      # Install dependencies
      RUN apt-get update && apt-get install -y \
          gettext-base \
          && rm -rf /var/lib/apt/lists/*
      
      # Create nginx configuration
      RUN echo 'server { \
          listen 80; \
          server_name localhost; \
          \
          # API requests \
          location /api/ { \
              proxy_pass http://${BACKEND_HOST}:5000/; \
              proxy_http_version 1.1; \
              proxy_set_header Upgrade $http_upgrade; \
              proxy_set_header Connection "upgrade"; \
              proxy_set_header Host $host; \
              proxy_set_header X-Real-IP $remote_addr; \
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \
              proxy_set_header X-Forwarded-Proto $scheme; \
              proxy_cache_bypass $http_upgrade; \
          } \
          \
          # Frontend \
          location / { \
              proxy_pass http://${FRONTEND_HOST}:4000; \
              proxy_http_version 1.1; \
              proxy_set_header Upgrade $http_upgrade; \
              proxy_set_header Connection "upgrade"; \
              proxy_set_header Host $host; \
              proxy_set_header X-Real-IP $remote_addr; \
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \
              proxy_set_header X-Forwarded-Proto $scheme; \
              proxy_cache_bypass $http_upgrade; \
          } \
          \
          # Health check \
          location /health { \
              access_log off; \
              return 200 "healthy\\n"; \
          } \
      }' > /etc/nginx/conf.d/default.conf.template \
      EOF
    - docker build -t $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHA -f Dockerfile.nginx .
    - docker push $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/nginx:latest
    - docker push $CI_REGISTRY_IMAGE/nginx:latest

# Option 1: Deploy using SSH access to the Docker Swarm manager
deploy-ssh:
  stage: deploy
  image: docker:20.10.16
  variables:
    # Replace with your actual Swarm manager IP or hostname
    SWARM_MANAGER: "192.168.1.100"  # REPLACE THIS WITH YOUR ACTUAL IP
    SSH_USER: "your-ssh-user"       # REPLACE THIS WITH YOUR ACTUAL SSH USER
  before_script:
    # Set up SSH for connecting to the Swarm manager
    - apk add --no-cache openssh-client
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config
  script:
    - |
      cat > docker-compose.prod.yml << EOF
      version: '3.8'
      
      services:
        frontend:
          image: ${CI_REGISTRY_IMAGE}/frontend:${CI_COMMIT_SHA}
          deploy:
            replicas: 1
            restart_policy:
              condition: on-failure
              max_attempts: 3
            resources:
              limits:
                cpus: '0.5'
                memory: 512M
          networks:
            - app-network
          environment:
            - PORT=4000
            - REACT_APP_API_URL=/api
            - NODE_ENV=production
          healthcheck:
            test: ["CMD", "wget", "-qO-", "http://localhost:4000/health"]
            interval: 30s
            timeout: 10s
            retries: 3
            start_period: 40s
      
        backend:
          image: ${CI_REGISTRY_IMAGE}/backend:${CI_COMMIT_SHA}
          deploy:
            replicas: 1
            restart_policy:
              condition: on-failure
              max_attempts: 3
            resources:
              limits:
                cpus: '0.5'
                memory: 512M
          networks:
            - app-network
          environment:
            - PORT=5000
            - MONGODB_URI=${MONGODB_URI}
            - NODE_ENV=production
          healthcheck:
            test: ["CMD", "wget", "-qO-", "http://localhost:5000/health"]
            interval: 30s
            timeout: 10s
            retries: 3
            start_period: 20s
      
        nginx:
          image: ${CI_REGISTRY_IMAGE}/nginx:${CI_COMMIT_SHA}
          deploy:
            replicas: 1
            restart_policy:
              condition: on-failure
              delay: 10s
              max_attempts: 5
            resources:
              limits:
                cpus: '0.2'
                memory: 128M
          ports:
            - "80:80"
          networks:
            - app-network
          environment:
            - FRONTEND_HOST=frontend
            - BACKEND_HOST=backend
          healthcheck:
            test: ["CMD", "wget", "-qO-", "http://localhost/health"]
            interval: 30s
            timeout: 10s
            retries: 3
            start_period: 5s
      
      networks:
        app-network:
          driver: overlay
          attachable: true
          driver_opts:
            com.docker.network.driver.mtu: "1450"
      EOF
    - scp docker-compose.prod.yml ${SSH_USER}@${SWARM_MANAGER}:~/docker-compose.prod.yml
    - ssh ${SSH_USER}@${SWARM_MANAGER} "docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY && docker stack deploy -c ~/docker-compose.prod.yml myapp"
  only:
    - main  # Only deploy from the main branch
  environment:
    name: production
  when: manual  # Makes this job manual so you can trigger it when ready

# Option 2: Simple deploy using artifact transfer (no Docker context required)
deploy-artifact:
  stage: deploy
  image: alpine:latest
  variables:
    # Replace with your actual Swarm manager IP or hostname
    SWARM_MANAGER: "192.168.1.100"  # REPLACE THIS WITH YOUR ACTUAL IP
    SSH_USER: "your-ssh-user"       # REPLACE THIS WITH YOUR ACTUAL SSH USER
  before_script:
    - apk add --no-cache openssh-client
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config
  script:
    - |
      cat > docker-compose.prod.yml << EOF
      version: '3.8'
      
      services:
        frontend:
          image: ${CI_REGISTRY_IMAGE}/frontend:${CI_COMMIT_SHA}
          deploy:
            replicas: 1
            restart_policy:
              condition: on-failure
              max_attempts: 3
          networks:
            - app-network
          environment:
            - PORT=4000
            - REACT_APP_API_URL=/api
            - NODE_ENV=production
      
        backend:
          image: ${CI_REGISTRY_IMAGE}/backend:${CI_COMMIT_SHA}
          deploy:
            replicas: 1
            restart_policy:
              condition: on-failure
              max_attempts: 3
          networks:
            - app-network
          environment:
            - PORT=5000
            - MONGODB_URI=${MONGODB_URI}
            - NODE_ENV=production
      
        nginx:
          image: ${CI_REGISTRY_IMAGE}/nginx:${CI_COMMIT_SHA}
          deploy:
            replicas: 1
            restart_policy:
              condition: on-failure
              delay: 10s
              max_attempts: 5
          ports:
            - "80:80"
          networks:
            - app-network
          environment:
            - FRONTEND_HOST=frontend
            - BACKEND_HOST=backend
      
      networks:
        app-network:
          driver: overlay
          attachable: true
      EOF
    - |
      cat > deploy.sh << 'EOF'
      #!/bin/sh
      set -e
      
      # Login to registry
      echo "Logging in to registry..."
      docker login -u $1 -p $2 $3
      
      # Deploy stack
      echo "Deploying stack..."
      docker stack deploy -c docker-compose.prod.yml myapp
      
      echo "Deployment completed!"
      EOF
    - chmod +x deploy.sh
    - scp docker-compose.prod.yml deploy.sh ${SSH_USER}@${SWARM_MANAGER}:~/
    - ssh ${SSH_USER}@${SWARM_MANAGER} "./deploy.sh $CI_REGISTRY_USER $CI_REGISTRY_PASSWORD $CI_REGISTRY"
  only:
    - main
  environment:
    name: production
  when: manual  # Makes this job manual so you can trigger it when ready