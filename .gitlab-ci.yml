stages:
  - build
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""

# --- FRONTEND BUILD (OPTIMIZED) ---
build-frontend:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - mkdir -p temp
    # 1. Create server.js for the production runner
    - |
      cat > temp/server.js << 'EOF'
      const express = require("express");
      const path = require("path");
      const app = express();
      const PORT = process.env.PORT || 4000;
      app.get("/health", (req, res) => res.status(200).send("OK"));
      app.use(express.static(path.join(__dirname, "build")));
      app.get("*", (req, res) => res.sendFile(path.join(__dirname, "build", "index.html")));
      app.listen(PORT, "0.0.0.0", () => console.log(`Frontend running on ${PORT}`));
      EOF
    # 2. Optimized Multi-Stage Dockerfile
    - |
      cat > temp/Dockerfile.frontend << 'EOF'
      # --- Stage 1: Build ---
      FROM node:18-alpine as build
      WORKDIR /app
      # Copy package files first to leverage Docker Cache
      COPY package*.json ./
      # Install dependencies (only if package.json changes)
      RUN if [ -f package-lock.json ]; then npm ci; else npm install; fi
      # Copy source code
      COPY . .
      # Build Arguments
      ARG REACT_APP_GOOGLE_CLIENT_ID
      ARG REACT_APP_API_URL
      ENV REACT_APP_GOOGLE_CLIENT_ID=$REACT_APP_GOOGLE_CLIENT_ID
      ENV REACT_APP_API_URL=$REACT_APP_API_URL
      ENV CI=false
      # CRITICAL: Disables source maps to save ~40% Memory
      ENV GENERATE_SOURCEMAP=false 
      RUN npm run build
      
      # --- Stage 2: Production ---
      FROM node:18-alpine
      WORKDIR /app
      # Copy only built artifacts
      COPY --from=build /app/build ./build
      COPY server.js .
      RUN npm init -y && npm install express@4.18.2
      EXPOSE 4000
      CMD ["node", "server.js"]
      EOF
    - mkdir -p temp/frontend
    - cp -r frontend/* temp/frontend/ || echo "No files"
    - cp temp/server.js temp/frontend/
    - cd temp/frontend
    - docker build --build-arg REACT_APP_GOOGLE_CLIENT_ID="$GOOGLE_CLIENT_ID" --build-arg REACT_APP_API_URL="/api" -t $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA -f ../Dockerfile.frontend .
    - docker push $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/frontend:latest
    - docker push $CI_REGISTRY_IMAGE/frontend:latest

# --- BACKEND BUILD (OPTIMIZED) ---
build-backend:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - mkdir -p temp
    - |
      cat > temp/Dockerfile.backend << 'EOF'
      FROM node:18-alpine
      WORKDIR /app
      # Cache layer: Install deps first
      COPY package*.json ./
      RUN npm ci --only=production || npm install --production
      RUN mkdir -p logs
      # Copy app code
      COPY . .
      EXPOSE 5000
      CMD ["node", "server.js"]
      EOF
    - mkdir -p temp/backend
    - cp -r backend/* temp/backend/ || echo "No files"
    - cd temp/backend
    - docker build -t $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA -f ../Dockerfile.backend .
    - docker push $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/backend:latest
    - docker push $CI_REGISTRY_IMAGE/backend:latest

# --- NGINX BUILD ---
build-nginx:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - mkdir -p temp/nginx
    - |
      cat > temp/nginx/default.conf.template << 'EOF'
      server { listen 8080; server_name app.medicalwaste.kz api.medicalwaste.kz; return 301 https://$server_name$request_uri; }
      server {
          listen 8443 ssl;
          server_name app.medicalwaste.kz;
          ssl_certificate /etc/letsencrypt/live/app.medicalwaste.kz/fullchain.pem;
          ssl_certificate_key /etc/letsencrypt/live/app.medicalwaste.kz/privkey.pem;
          location /api/ {
              proxy_pass http://${BACKEND_HOST}:5000;
              proxy_set_header Host $host;
          }
          location / {
              proxy_pass http://${FRONTEND_HOST}:4000;
              proxy_set_header Host $host;
          }
      }
      EOF
    - |
      cat > temp/nginx/docker-entrypoint.sh << 'EOF'
      #!/bin/sh
      envsubst '${FRONTEND_HOST} ${BACKEND_HOST} ${SERVER_NAME}' < /etc/nginx/conf.d/default.conf.template > /etc/nginx/conf.d/default.conf
      exec "$@"
      EOF
    - |
      cat > temp/nginx/Dockerfile << 'EOF'
      FROM nginx:1.25-alpine
      RUN apk add --no-cache gettext bash
      COPY default.conf.template /etc/nginx/conf.d/default.conf.template
      COPY docker-entrypoint.sh /docker-entrypoint.sh
      RUN chmod +x /docker-entrypoint.sh
      ENTRYPOINT ["/docker-entrypoint.sh"]
      CMD ["nginx", "-g", "daemon off;"]
      EOF
    - cd temp/nginx
    - docker build -t $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHA -f Dockerfile .
    - docker push $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/nginx:latest
    - docker push $CI_REGISTRY_IMAGE/nginx:latest

# --- DEPLOYMENT (DISTRIBUTED) ---
deploy:
  stage: deploy
  image: alpine:latest
  variables:
    SWARM_MANAGER: $NEW_SERVER_IP
    SSH_USER: "ubuntu"
  dependencies:
    - build-frontend
    - build-backend
    - build-nginx
  before_script:
    - apk add --no-cache openssh-client
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config
  script:
    - |
      cat > docker-compose.prod.yml << EOF
      version: '3.8'
      services:
        frontend:
          image: $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA
          deploy:
            replicas: 1
            # UNLOCKED: Can run on any worker node
            resources: { limits: { memory: 250M } }
            restart_policy: { condition: on-failure, delay: 10s }
          networks: [myapp_app-network]
          environment:
            - PORT=4000
            - REACT_APP_API_URL=/api
            - NODE_ENV=production
            - REACT_APP_GOOGLE_CLIENT_ID=$GOOGLE_CLIENT_ID
      
        backend:
          image: $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA
          deploy:
            replicas: 1
            # UNLOCKED: Can run on any worker node
            resources: { limits: { memory: 300M } }
            restart_policy: { condition: on-failure, delay: 10s }
          networks: [myapp_app-network]
          environment:
            - PORT=5000
            - MONGODB_URI=mongodb://myapp_mongodb:27017/trashbin_db
            - NODE_ENV=production
            - JWT_SECRET=$JWT_SECRET
            - JWT_REFRESH_SECRET=$JWT_REFRESH_SECRET
            - GOOGLE_CLIENT_ID=$GOOGLE_CLIENT_ID
            - GOOGLE_CLIENT_SECRET=$GOOGLE_CLIENT_SECRET
            - GOOGLE_REDIRECT_URI=$GOOGLE_REDIRECT_URI
            - FRONTEND_URL=$FRONTEND_URL
            - TELEGRAM_BOT_TOKEN=$TELEGRAM_BOT_TOKEN
            - BCRYPT_ROUNDS=12
      
        mongodb:
          image: mongo:4.4
          deploy:
            replicas: 1
            # LOCKED: Must stay on Master for Data Persistence
            placement: { constraints: [node.hostname == ip-10-0-1-166] }
            resources: { limits: { memory: 350M } }
            restart_policy: { condition: on-failure, delay: 15s }
          volumes: [mongodb_data:/data/db]
          networks: [myapp_app-network]
      
        nginx:
          image: $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHA
          deploy:
            replicas: 1
            # UNLOCKED: Can run on any worker node
            resources: { limits: { memory: 64M } }
          ports: ["80:8080", "443:8443"]
          volumes: ["/etc/letsencrypt:/etc/letsencrypt:ro"]
          networks: [myapp_app-network]
          environment:
            - FRONTEND_HOST=myapp_frontend
            - BACKEND_HOST=myapp_backend
            - SERVER_NAME=$SERVER_NAME

      networks:
        myapp_app-network:
          external: true
      
      volumes:
        mongodb_data:
      EOF

    - |
      cat > deploy.sh << 'EOF'
      #!/bin/sh
      set -e
      REGISTRY_USER=$1; REGISTRY_PASS=$2; REGISTRY_URL=$3; IMAGE_BASE=$4; COMMIT_SHA=$5
      echo "$REGISTRY_PASS" | docker login --username "$REGISTRY_USER" --password-stdin "$REGISTRY_URL"
      docker system prune -f
      docker pull ${IMAGE_BASE}/backend:${COMMIT_SHA}
      docker pull ${IMAGE_BASE}/frontend:${COMMIT_SHA}
      docker pull ${IMAGE_BASE}/nginx:${COMMIT_SHA}
      docker stack deploy --with-registry-auth -c docker-compose.prod.yml myapp
      sleep 10
      docker image prune -f
      EOF

    - scp docker-compose.prod.yml $SSH_USER@$SWARM_MANAGER:~/docker-compose.prod.yml
    - scp deploy.sh $SSH_USER@$SWARM_MANAGER:~/deploy.sh
    - ssh $SSH_USER@$SWARM_MANAGER "bash ~/deploy.sh '$CI_REGISTRY_USER' '$CI_REGISTRY_PASSWORD' '$CI_REGISTRY' '$CI_REGISTRY_IMAGE' '$CI_COMMIT_SHA'"
  only:
    - main
