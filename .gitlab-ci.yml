stages:
  - build
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""

# Build images separately to avoid context issues
build-frontend:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    # Create a fixed Dockerfile that properly escapes the content
    - |
      cat > Dockerfile.frontend << 'EOF'
      # Build stage
      FROM node:18-alpine as build

      WORKDIR /app

      # Copy package.json and package-lock.json
      COPY package*.json ./

      # Install dependencies
      RUN npm ci

      # Copy application code
      COPY . .

      # Build the application
      RUN CI=false npm run build

      # Production stage
      FROM node:18-alpine

      WORKDIR /app

      # Copy build files
      COPY --from=build /app/build ./build

      # Install express for serving
      RUN npm init -y && \
          npm install express@4.18.2

      # Create server file
      RUN echo 'const express = require("express");\n\
      const path = require("path");\n\
      const app = express();\n\
      const PORT = process.env.PORT || 4000;\n\
      \n\
      // Health check endpoint\n\
      app.get("/health", (req, res) => {\n\
        res.status(200).send("OK");\n\
      });\n\
      \n\
      // Serve static files from the React build\n\
      app.use(express.static(path.join(__dirname, "build")));\n\
      \n\
      // Handle React routing, return all requests to React app\n\
      app.get("*", (req, res) => {\n\
        res.sendFile(path.join(__dirname, "build", "index.html"));\n\
      });\n\
      \n\
      // Make sure to listen on all interfaces\n\
      app.listen(PORT, "0.0.0.0", () => {\n\
        console.log(`Frontend server running on port ${PORT}`);\n\
      });' > server.js

      # Expose port
      EXPOSE 4000

      # Start the server
      CMD ["node", "server.js"]
      EOF
    # Copy actual frontend files
    - mkdir -p frontend-temp
    - cp -r frontend/* frontend-temp/ || echo "No frontend files to copy"
    - cd frontend-temp
    - docker build -t $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA -f ../Dockerfile.frontend .
    - docker push $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/frontend:latest
    - docker push $CI_REGISTRY_IMAGE/frontend:latest
    - cd ..

build-backend:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    # Create a fixed Dockerfile that properly escapes the content
    - |
      cat > Dockerfile.backend << 'EOF'
      FROM node:18-alpine

      # Create app directory
      WORKDIR /app

      # Copy package files
      COPY package*.json ./

      # Install dependencies
      RUN npm ci --only=production

      # Copy application code
      COPY . .

      # Create a minimal server if one doesn't exist
      RUN if [ ! -f server.js ]; then \
          echo 'const express = require("express");\n\
      const app = express();\n\
      const PORT = process.env.PORT || 5000;\n\
      \n\
      // Health check endpoint\n\
      app.get("/health", (req, res) => {\n\
        res.status(200).send("OK");\n\
      });\n\
      \n\
      // Example API endpoint\n\
      app.get("/api", (req, res) => {\n\
        res.json({ message: "API is working" });\n\
      });\n\
      \n\
      // Start server on all interfaces\n\
      app.listen(PORT, "0.0.0.0", () => {\n\
        console.log(`Backend server running on port ${PORT}`);\n\
      });' > server.js; \
      fi

      # Add a health check endpoint if it doesn't exist
      RUN grep -q "app.get('/health'" server.js || \
          echo "\n// Health check endpoint\napp.get('/health', (req, res) => { res.status(200).send('OK'); });\n" >> server.js

      # Make sure server listens on all interfaces
      RUN grep -q "app.listen.*0.0.0.0" server.js || \
          sed -i "s/app.listen(PORT)/app.listen(PORT, '0.0.0.0')/g" server.js || \
          echo "Warning: Could not update listen binding. Please check manually."

      # Expose the API port
      EXPOSE 5000

      # Start the application
      CMD ["node", "server.js"]
      EOF
    # Copy actual backend files
    - mkdir -p backend-temp
    - cp -r backend/* backend-temp/ || echo "No backend files to copy"
    - cd backend-temp
    - docker build -t $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA -f ../Dockerfile.backend .
    - docker push $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/backend:latest
    - docker push $CI_REGISTRY_IMAGE/backend:latest
    - cd ..

build-nginx:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - |
      cat > Dockerfile.nginx << 'EOF'
      FROM nginx:1.25-alpine

      # Install dependencies
      RUN apk add --no-cache gettext

      # Create nginx configuration
      RUN echo 'server { \
          listen 8080; \
          server_name localhost; \
          \
          # API requests \
          location /api/ { \
              proxy_pass http://${BACKEND_HOST}:5000/; \
              proxy_http_version 1.1; \
              proxy_set_header Upgrade $http_upgrade; \
              proxy_set_header Connection "upgrade"; \
              proxy_set_header Host $host; \
              proxy_set_header X-Real-IP $remote_addr; \
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \
              proxy_set_header X-Forwarded-Proto $scheme; \
              proxy_cache_bypass $http_upgrade; \
          } \
          \
          # Frontend \
          location / { \
              proxy_pass http://${FRONTEND_HOST}:4000; \
              proxy_http_version 1.1; \
              proxy_set_header Upgrade $http_upgrade; \
              proxy_set_header Connection "upgrade"; \
              proxy_set_header Host $host; \
              proxy_set_header X-Real-IP $remote_addr; \
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \
              proxy_set_header X-Forwarded-Proto $scheme; \
              proxy_cache_bypass $http_upgrade; \
          } \
          \
          # Health check \
          location /health { \
              access_log off; \
              return 200 "healthy\\n"; \
          } \
      }' > /etc/nginx/conf.d/default.conf.template

      # Create a simple entrypoint script
      RUN echo '#!/bin/sh \n\
      set -e \n\
      \n\
      # Replace environment variables in the config \n\
      envsubst "\$FRONTEND_HOST \$BACKEND_HOST" < /etc/nginx/conf.d/default.conf.template > /etc/nginx/conf.d/default.conf \n\
      \n\
      # Start nginx \n\
      exec "$@"' > /docker-entrypoint.sh && chmod +x /docker-entrypoint.sh

      # Use our custom entrypoint
      ENTRYPOINT ["/docker-entrypoint.sh"]
      CMD ["nginx", "-g", "daemon off;"]
      EOF
    - docker build -t $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHA -f Dockerfile.nginx .
    - docker push $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/nginx:latest
    - docker push $CI_REGISTRY_IMAGE/nginx:latest

# Deploy to Docker Swarm using SSH access to the manager node
deploy:
  stage: deploy
  image: alpine:latest
  variables:
    # Your actual Swarm manager public IP
    SWARM_MANAGER: "13.48.178.39"
    SSH_USER: "ubuntu"
  before_script:
    # Set up SSH for connecting to the Swarm manager
    - apk add --no-cache openssh-client
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config
  script:
    - |
      cat > docker-compose.prod.yml << EOF
      version: '3.8'

      services:
        frontend:
          image: ${CI_REGISTRY_IMAGE}/frontend:${CI_COMMIT_SHA}
          deploy:
            replicas: 1
            restart_policy:
              condition: any
              delay: 5s
              max_attempts: 5
          networks:
            - app-network
          environment:
            - PORT=4000
            - REACT_APP_API_URL=/api
            - NODE_ENV=production

        backend:
          image: ${CI_REGISTRY_IMAGE}/backend:${CI_COMMIT_SHA}
          deploy:
            replicas: 1
            restart_policy:
              condition: any
              delay: 5s
              max_attempts: 5
          networks:
            - app-network
          environment:
            - PORT=5000
            - MONGODB_URI=mongodb://mongodb:27017/myapp
            - NODE_ENV=production

        # Add MongoDB service for the backend
        mongodb:
          image: mongo:4.4
          deploy:
            replicas: 1
            restart_policy:
              condition: on-failure
          volumes:
            - mongo-data:/data/db
          networks:
            - app-network

        nginx:
          image: ${CI_REGISTRY_IMAGE}/nginx:${CI_COMMIT_SHA}
          deploy:
            replicas: 1
            restart_policy:
              condition: any
              delay: 5s
              max_attempts: 5
          ports:
            - "8080:8080"
          networks:
            - app-network
          environment:
            - FRONTEND_HOST=frontend
            - BACKEND_HOST=backend

      networks:
        app-network:
          driver: overlay
          attachable: true

      volumes:
        mongo-data:
      EOF
    - |
      cat > deploy.sh << 'EOF'
      #!/bin/sh
      set -e
      
      # Login to registry
      echo "Logging in to registry..."
      docker login -u $1 -p $2 $3
      
      # Deploy stack
      echo "Deploying stack..."
      docker stack deploy -c docker-compose.prod.yml myapp
      
      # Verify deployment
      echo "Verifying deployment..."
      sleep 5
      docker service ls
      
      echo "Deployment completed!"
      EOF
    - chmod +x deploy.sh
    - scp docker-compose.prod.yml deploy.sh ${SSH_USER}@${SWARM_MANAGER}:~/
    - ssh ${SSH_USER}@${SWARM_MANAGER} "./deploy.sh $CI_REGISTRY_USER $CI_REGISTRY_PASSWORD $CI_REGISTRY"
  only:
    - main
  environment:
    name: production
  # Set to manual if you want to trigger deployments manually
  when: manual