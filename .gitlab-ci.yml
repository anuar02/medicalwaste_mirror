stages:
  - build
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""

# --- REUSABLE ANCHOR FOR DOCKER LOGIN ---
.docker_login: &docker_login
  - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY

# --- FRONTEND BUILD ---
build-frontend:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - *docker_login
    - mkdir -p temp
    - |
      cat > temp/server.js << 'EOF'
      const express = require("express");
      const path = require("path");
      const app = express();
      const PORT = process.env.PORT || 4000;
      app.get("/health", (req, res) => res.status(200).send("OK"));
      app.use(express.static(path.join(__dirname, "build")));
      app.get("*", (req, res) => res.sendFile(path.join(__dirname, "build", "index.html")));
      app.listen(PORT, "0.0.0.0", () => console.log(`Frontend running on ${PORT}`));
      EOF
    - |
      cat > temp/Dockerfile.frontend << 'EOF'
      FROM node:18-alpine as build
      WORKDIR /app
      COPY package*.json ./
      RUN if [ -f package-lock.json ]; then npm ci; else npm install; fi
      COPY . .
      ARG REACT_APP_GOOGLE_CLIENT_ID
      ARG REACT_APP_API_URL
      ENV REACT_APP_GOOGLE_CLIENT_ID=$REACT_APP_GOOGLE_CLIENT_ID
      ENV REACT_APP_API_URL=$REACT_APP_API_URL
      ENV CI=false
      ENV GENERATE_SOURCEMAP=false 
      RUN npm run build
      
      FROM node:18-alpine
      WORKDIR /app
      COPY --from=build /app/build ./build
      COPY server.js .
      RUN npm init -y && npm install express@4.18.2
      EXPOSE 4000
      CMD ["node", "server.js"]
      EOF
    - mkdir -p temp/frontend
    - cp -r frontend/* temp/frontend/ || echo "No files"
    - cp temp/server.js temp/frontend/
    - cd temp/frontend
    - docker build --build-arg REACT_APP_GOOGLE_CLIENT_ID="$GOOGLE_CLIENT_ID" --build-arg REACT_APP_API_URL="/api" -t $CI_REGISTRY_IMAGE/frontend:latest -f ../Dockerfile.frontend .
    - docker push $CI_REGISTRY_IMAGE/frontend:latest

# --- BACKEND BUILD ---
build-backend:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - *docker_login
    - mkdir -p temp
    - |
      cat > temp/Dockerfile.backend << 'EOF'
      FROM node:18-alpine
      WORKDIR /app
      COPY package*.json ./
      RUN npm ci --only=production || npm install --production
      RUN mkdir -p logs
      COPY . .
      EXPOSE 5000
      CMD ["node", "server.js"]
      EOF
    - mkdir -p temp/backend
    - cp -r backend/* temp/backend/ || echo "No files"
    - cd temp/backend
    - docker build -t $CI_REGISTRY_IMAGE/backend:latest -f ../Dockerfile.backend .
    - docker push $CI_REGISTRY_IMAGE/backend:latest

# --- NGINX BUILD ---
build-nginx:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - *docker_login
    - mkdir -p temp/nginx
    - |
      cat > temp/nginx/default.conf.template << 'EOF'
      server { listen 8080; server_name app.medicalwaste.kz api.medicalwaste.kz; return 301 https://$server_name$request_uri; }
      server {
          listen 8443 ssl;
          server_name app.medicalwaste.kz;
          ssl_certificate /etc/letsencrypt/live/app.medicalwaste.kz/fullchain.pem;
          ssl_certificate_key /etc/letsencrypt/live/app.medicalwaste.kz/privkey.pem;
          location /api/ {
              proxy_pass http://${BACKEND_HOST}:5000;
              proxy_set_header Host $host;
          }
          location / {
              proxy_pass http://${FRONTEND_HOST}:4000;
              proxy_set_header Host $host;
          }
      }
      EOF
    - |
      cat > temp/nginx/docker-entrypoint.sh << 'EOF'
      #!/bin/sh
      envsubst '${FRONTEND_HOST} ${BACKEND_HOST} ${SERVER_NAME}' < /etc/nginx/conf.d/default.conf.template > /etc/nginx/conf.d/default.conf
      exec "$@"
      EOF
    - |
      cat > temp/nginx/Dockerfile << 'EOF'
      FROM nginx:1.25-alpine
      RUN apk add --no-cache gettext bash
      COPY default.conf.template /etc/nginx/conf.d/default.conf.template
      COPY docker-entrypoint.sh /docker-entrypoint.sh
      RUN chmod +x /docker-entrypoint.sh
      ENTRYPOINT ["/docker-entrypoint.sh"]
      CMD ["nginx", "-g", "daemon off;"]
      EOF
    - cd temp/nginx
    - docker build -t $CI_REGISTRY_IMAGE/nginx:latest -f Dockerfile .
    - docker push $CI_REGISTRY_IMAGE/nginx:latest

# --- DEPLOYMENT ---
deploy:
  stage: deploy
  image: alpine:latest
  variables:
    SWARM_MANAGER: $NEW_SERVER_IP
    SSH_USER: "ubuntu"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  before_script:
    - apk add --no-cache openssh-client
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config
  script:
    - |
      cat > docker-compose.prod.yml << EOF
      version: '3.8'
      services:
        frontend:
          image: $CI_REGISTRY_IMAGE/frontend:latest
          deploy:
            replicas: 1
            resources: { limits: { memory: 250M } }
            restart_policy: { condition: on-failure }
          networks: [myapp_app-network]
          environment:
            - PORT=4000
            - REACT_APP_API_URL=/api
            - NODE_ENV=production
            - REACT_APP_GOOGLE_CLIENT_ID=$GOOGLE_CLIENT_ID
      
        backend:
          image: $CI_REGISTRY_IMAGE/backend:latest
          deploy:
            replicas: 1
            resources: { limits: { memory: 300M } }
            restart_policy: { condition: on-failure }
          networks: [myapp_app-network]
          environment:
            - PORT=5000
            - MONGODB_URI=mongodb://myapp_mongodb:27017/trashbin_db
            - NODE_ENV=production
            - JWT_SECRET=$JWT_SECRET
            - JWT_REFRESH_SECRET=$JWT_REFRESH_SECRET
            - GOOGLE_CLIENT_ID=$GOOGLE_CLIENT_ID
            - GOOGLE_CLIENT_SECRET=$GOOGLE_CLIENT_SECRET
            - GOOGLE_REDIRECT_URI=$GOOGLE_REDIRECT_URI
            - FRONTEND_URL=$FRONTEND_URL
            - TELEGRAM_BOT_TOKEN=$TELEGRAM_BOT_TOKEN
            - BCRYPT_ROUNDS=12
            - EMAIL_HOST=$SMTP_HOST
            - EMAIL_PORT=465
            - EMAIL_FROM=$SMTP_USER
            - EMAIL_USERNAME=$SMTP_USER
            - EMAIL_PASSWORD=$SMTP_PASS
            - TWILIO_ACCOUNT_SID=$TWILIO_ACCOUNT_SID
            - TWILIO_AUTH_TOKEN=$TWILIO_AUTH_TOKEN
            - TWILIO_WHATSAPP_FROM=$TWILIO_WHATSAPP_FROM
            - TWILIO_VERIFY_SERVICE_SID=$TWILIO_VERIFY_SERVICE_SID
      
        mongodb:
          image: mongo:4.4
          deploy:
            replicas: 1
            placement: { constraints: [node.role == manager] }
            resources: { limits: { memory: 350M } }
          volumes: [mongodb_data:/data/db]
          networks: [myapp_app-network]
      
        nginx:
          image: $CI_REGISTRY_IMAGE/nginx:latest
          deploy:
            replicas: 1
          ports: ["80:8080", "443:8443"]
          volumes: ["/etc/letsencrypt:/etc/letsencrypt:ro"]
          networks: [myapp_app-network]
          environment:
            - FRONTEND_HOST=myapp_frontend
            - BACKEND_HOST=myapp_backend
            - SERVER_NAME=$SERVER_NAME

      networks:
        myapp_app-network:
          external: true
      
      volumes:
        mongodb_data:
      EOF

    - |
      cat > deploy.sh << 'EOF'
      #!/bin/sh
      set -e
      REGISTRY_USER=$1; REGISTRY_PASS=$2; REGISTRY_URL=$3; IMAGE_BASE=$4
      echo "$REGISTRY_PASS" | docker login --username "$REGISTRY_USER" --password-stdin "$REGISTRY_URL"
      
      # Pull latest versions of everything
      docker pull ${IMAGE_BASE}/backend:latest
      docker pull ${IMAGE_BASE}/frontend:latest
      docker pull ${IMAGE_BASE}/nginx:latest
      
      # Swarm will compare image digests. It will ONLY restart services where 'latest' has a new digest.
      docker stack deploy --with-registry-auth -c docker-compose.prod.yml myapp
      
      sleep 10
      docker image prune -f
      EOF

    - scp docker-compose.prod.yml $SSH_USER@$SWARM_MANAGER:~/docker-compose.prod.yml
    - scp deploy.sh $SSH_USER@$SWARM_MANAGER:~/deploy.sh
    - ssh $SSH_USER@$SWARM_MANAGER "bash ~/deploy.sh '$CI_REGISTRY_USER' '$CI_REGISTRY_PASSWORD' '$CI_REGISTRY' '$CI_REGISTRY_IMAGE'"
